group llvm;

//  program will take in two parameters
//  parameter a will be the initialization of variables
//strings will be handled by a hard coded @.str variable
//  parameter b will be the rest of the program 


program(a,b) ::= <<
; ModuleID = 'nomain.c'
target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

<a>
@.str = private unnamed_addr constant [3 x i8] c"%d\00", align 1

define i32 @main() nounwind uwtable {
  %1 = alloca i32, align 4
  store i32 0, i32* %1
  <b>
  ret i32 0
}

declare i32 @printf(i8*, ...)
>>

//a is the variable name
//b is the variable value
declareInt(a,b) ::= <<

@<a> = global i32 <b>, align 4

>>

//a is the variable being printed out
//b is the current temp variable -1
//c is the current temp variable 
printStatement(a,b,c) ::= <<

%<b> = load i32* @<a>, align 4
%<c> = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([3 x i8]* @.str, i32 0, i32 0), i32 %<b>)

>>

//a is the resolution of the exp a
//b is the location that a is being stored
storeVar(a,b) ::= <<

store i32 %<a>, i32* @<b>, align 4

>>

//a is the resolution of the exp a
//b is the resolution of the exp b
//c is the current temp variable number
add(a,b,c) ::= <<

%<c> = add i32 %<a>, %<b>

>>

//a is the resolution of the exp a
//b is the resolution of the exp b
//c is the current temp variable number
sub(a,b,c) ::= <<

%<c> = sub i32 %<a>, %<b>

>>

//a is the resolution of the exp a
//b is the resolution of the exp b
//c is the current temp variable number
mult(a,b,c) ::= <<

%<c> = mul i32 %<a>, %<b>

>>

//a is the resolution of the exp a
//b is the resolution of the exp b
//c is the current temp variable number
div(a,b,c) ::= <<

%<c> = udiv i32 %<a>, %<b>

>>

//a is the resolution of the exp a
//b is the current temp variable -1
//c is the current temp variable 
int(a,b,c) ::= <<

%<b> = alloca i32, align 4
store i32 <a>, %<b>
%<c> = load i32* %<b>, align 4

>>

//a is the variable name
//b is the current temp variable
var(a,b) ::= <<

%<b> = load i32* @<a>, align 4

>>

//a is the resolution of exp a
//b is the resolution of exp b
//c is the current temp variable
eql(a,b,c) ::= <<

%<c> = icmp eq i32 %<a>, %<b>

>>

//a is the resolution of exp a
//b is the resolution of exp b
//c is the current temp variable
neq(a,b,c) ::= <<

%<c> = icmp ne i32 %<a>, %<b>

>>

//a is the resolution of exp a
//b is the resolution of exp b
//c is the current temp variable
sgt(a,b,c) ::= <<

%<c> = icmp sgt i32 %<a>, %<b>

>>

//a is the resolution of exp a
//b is the resolution of exp b
//c is the current temp variable
slt(a,b,c) ::= <<

%<c> = icmp slt i32 %<a>, %<b>

>>

//a is the variable name for the vector
//b is the number of elements vector a holds
vectorInit(a,b,c) ::= <<

%<a> = alloca [<b> x i32], align 16

>>